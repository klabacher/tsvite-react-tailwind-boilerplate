import { describe, it, expect } from 'vitest';
import { axe, toHaveNoViolations } from 'jest-axe';
import { renderApp } from '../test/test-utils';
import App from '../App';

expect.extend(toHaveNoViolations);

describe('Accessibility (a11y)', () => {
  describe('App Component', () => {
    it('should have no accessibility violations', async () => {
      const { container } = renderApp(<App />);
      const results = await axe(container);
      expect(results).toHaveNoViolations();
    });
  });

  describe('Semantic HTML', () => {
    it('should have proper heading hierarchy', () => {
      const { container } = renderApp(<App />);
      const headings = container.querySelectorAll('h1, h2, h3, h4, h5, h6');
      
      if (headings.length > 0) {
        // Check that h1 exists if there are any headings
        const h1s = container.querySelectorAll('h1');
        expect(h1s.length).toBeLessThanOrEqual(1);
      }
    });

    it('should have alt text on images', () => {
      const { container } = renderApp(<App />);
      const images = container.querySelectorAll('img');
      
      images.forEach((img) => {
        const alt = img.getAttribute('alt');
        expect(alt).toBeDefined();
        expect(alt).not.toBe('');
      });
    });

    it('should have proper button accessibility', () => {
      const { container } = renderApp(<App />);
      const buttons = container.querySelectorAll('button');
      
      buttons.forEach((button) => {
        // Button should have accessible text
        const hasText = button.textContent?.trim() !== '';
        const hasAriaLabel = button.hasAttribute('aria-label');
        const hasAriaLabelledBy = button.hasAttribute('aria-labelledby');
        
        expect(hasText || hasAriaLabel || hasAriaLabelledBy).toBe(true);
      });
    });

    it('should have proper link accessibility', () => {
      const { container } = renderApp(<App />);
      const links = container.querySelectorAll('a');
      
      links.forEach((link) => {
        // Links should have accessible text or aria-label
        const hasText = link.textContent?.trim() !== '';
        const hasAriaLabel = link.hasAttribute('aria-label');
        
        expect(hasText || hasAriaLabel).toBe(true);
        
        // External links should have proper attributes
        const href = link.getAttribute('href');
        if (href?.startsWith('http') && !href.includes(window.location.hostname)) {
          expect(link.getAttribute('rel')).toContain('noopener');
        }
      });
    });
  });

  describe('Form Accessibility', () => {
    it('should have labels for form inputs', () => {
      const { container } = renderApp(<App />);
      const inputs = container.querySelectorAll('input, textarea, select');
      
      inputs.forEach((input) => {
        const id = input.getAttribute('id');
        const hasLabel = id && container.querySelector(`label[for="${id}"]`);
        const hasAriaLabel = input.hasAttribute('aria-label');
        const hasAriaLabelledBy = input.hasAttribute('aria-labelledby');
        const hasParentLabel = input.closest('label') !== null;
        
        expect(hasLabel || hasAriaLabel || hasAriaLabelledBy || hasParentLabel).toBe(true);
      });
    });

    it('should have proper required field indication', () => {
      const { container } = renderApp(<App />);
      const requiredInputs = container.querySelectorAll('[required]');
      
      requiredInputs.forEach((input) => {
        const hasAriaRequired = input.getAttribute('aria-required') === 'true';
        const hasRequired = input.hasAttribute('required');
        expect(hasAriaRequired || hasRequired).toBe(true);
      });
    });
  });

  describe('Keyboard Navigation', () => {
    it('should have focusable interactive elements', () => {
      const { container } = renderApp(<App />);
      const interactiveElements = container.querySelectorAll(
        'a, button, input, textarea, select, [tabindex]'
      );
      
      interactiveElements.forEach((element) => {
        const tabIndex = element.getAttribute('tabindex');
        // Elements should not have tabindex of -1 unless intentionally hidden
        if (tabIndex === '-1') {
          // Should have aria-hidden or be visually hidden
          const isHidden = 
            element.getAttribute('aria-hidden') === 'true' ||
            (element as HTMLElement).offsetParent === null;
          expect(isHidden).toBe(true);
        }
      });
    });

    it('should have visible focus indicators', () => {
      const { container } = renderApp(<App />);
      const focusableElements = container.querySelectorAll(
        'a, button, input, textarea, select, [tabindex="0"]'
      );
      
      // At least verify elements exist and are potentially focusable
      expect(focusableElements.length).toBeGreaterThanOrEqual(0);
    });
  });

  describe('Color and Contrast', () => {
    it('should not use color as only indicator', () => {
      const { container } = renderApp(<App />);
      const errorElements = container.querySelectorAll('[class*="error"], [class*="Error"]');
      
      errorElements.forEach((element) => {
        // Error states should have more than just color indication
        const hasIcon = element.querySelector('svg, img, [class*="icon"]');
        const hasText = element.textContent?.trim() !== '';
        const hasAriaLabel = element.hasAttribute('aria-label');
        const hasRole = element.hasAttribute('role');
        
        expect(hasIcon || hasText || hasAriaLabel || hasRole).toBe(true);
      });
    });
  });

  describe('ARIA Roles', () => {
    it('should have proper ARIA landmarks', () => {
      const { container } = renderApp(<App />);
      
      // Check for semantic or ARIA landmarks
      // At minimum, the app should have a main content area
      // (may be implicit through semantic HTML)
      expect(container.children.length).toBeGreaterThan(0);
    });

    it('should have proper dialog/modal accessibility', () => {
      const { container } = renderApp(<App />);
      const dialogs = container.querySelectorAll('[role="dialog"], [role="alertdialog"]');
      
      dialogs.forEach((dialog) => {
        expect(dialog.hasAttribute('aria-labelledby') || dialog.hasAttribute('aria-label')).toBe(true);
      });
    });
  });
});
