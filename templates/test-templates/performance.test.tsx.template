import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderApp, waitFor } from '../test/test-utils';
import App from '../App';

describe('Performance Tests', () => {
  beforeEach(() => {
    vi.useFakeTimers({ shouldAdvanceTime: true });
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  describe('Render Performance', () => {
    it('should render within acceptable time', async () => {
      const startTime = performance.now();
      renderApp(<App />);
      const endTime = performance.now();
      
      const renderTime = endTime - startTime;
      // Initial render should be under 500ms
      expect(renderTime).toBeLessThan(500);
    });

    it('should not cause excessive re-renders', async () => {
      const renderCount = { count: 0 };
      
      // Using a wrapper to track renders
      function TrackingApp() {
        renderCount.count++;
        return <App />;
      }
      
      renderApp(<TrackingApp />);
      
      // Allow time for any async effects
      await vi.advanceTimersByTimeAsync(100);
      
      // Should not have more than 3 initial renders (strict mode doubles renders)
      expect(renderCount.count).toBeLessThanOrEqual(3);
    });
  });

  describe('Memory Usage', () => {
    it('should not have memory leaks on unmount', () => {
      const { unmount } = renderApp(<App />);
      
      // Get initial memory if available
      const initialMemory = (performance as any).memory?.usedJSHeapSize;
      
      unmount();
      
      // If memory API is available, check for leaks
      if (initialMemory) {
        const finalMemory = (performance as any).memory?.usedJSHeapSize;
        // Memory should not significantly increase after unmount
        expect(finalMemory).toBeLessThanOrEqual(initialMemory * 1.5);
      }
    });

    it('should clean up event listeners on unmount', () => {
      const addEventListenerSpy = vi.spyOn(window, 'addEventListener');
      const removeEventListenerSpy = vi.spyOn(window, 'removeEventListener');
      
      const { unmount } = renderApp(<App />);
      const listenersAdded = addEventListenerSpy.mock.calls.length;
      
      unmount();
      
      // All listeners added should be removed
      const listenersRemoved = removeEventListenerSpy.mock.calls.length;
      expect(listenersRemoved).toBeGreaterThanOrEqual(listenersAdded);
      
      addEventListenerSpy.mockRestore();
      removeEventListenerSpy.mockRestore();
    });

    it('should clean up timers on unmount', async () => {
      const setIntervalSpy = vi.spyOn(global, 'setInterval');
      const clearIntervalSpy = vi.spyOn(global, 'clearInterval');
      
      const { unmount } = renderApp(<App />);
      const intervalsSet = setIntervalSpy.mock.calls.length;
      
      unmount();
      
      // All intervals should be cleared
      const intervalsCleared = clearIntervalSpy.mock.calls.length;
      expect(intervalsCleared).toBeGreaterThanOrEqual(intervalsSet);
      
      setIntervalSpy.mockRestore();
      clearIntervalSpy.mockRestore();
    });
  });

  describe('Bundle Size Indicators', () => {
    it('should have reasonable component tree depth', () => {
      const { container } = renderApp(<App />);
      
      function getMaxDepth(element: Element, depth: number = 0): number {
        let maxDepth = depth;
        for (const child of element.children) {
          maxDepth = Math.max(maxDepth, getMaxDepth(child, depth + 1));
        }
        return maxDepth;
      }
      
      const maxDepth = getMaxDepth(container);
      // Component tree should not be excessively deep (avoid over-nesting)
      expect(maxDepth).toBeLessThan(50);
    });

    it('should not have excessive DOM nodes', () => {
      const { container } = renderApp(<App />);
      
      function countNodes(element: Element): number {
        let count = 1;
        for (const child of element.children) {
          count += countNodes(child);
        }
        return count;
      }
      
      const nodeCount = countNodes(container);
      // Initial render should not have too many DOM nodes
      expect(nodeCount).toBeLessThan(1000);
    });
  });

  describe('Async Operations', () => {
    it('should handle async operations without blocking', async () => {
      const startTime = performance.now();
      renderApp(<App />);
      
      // Simulate waiting for async operations
      await vi.advanceTimersByTimeAsync(1000);
      
      const endTime = performance.now();
      // Should not take longer than timer advance + some margin
      expect(endTime - startTime).toBeLessThan(2000);
    });

    it('should debounce rapid interactions', async () => {
      const { container } = renderApp(<App />);
      const buttons = container.querySelectorAll('button');
      
      if (buttons.length > 0) {
        const button = buttons[0];
        const clickSpy = vi.fn();
        button.addEventListener('click', clickSpy);
        
        // Rapid clicks
        for (let i = 0; i < 10; i++) {
          button.click();
        }
        
        // All clicks should register (debouncing is handled at handler level)
        expect(clickSpy).toHaveBeenCalledTimes(10);
      }
    });
  });

  describe('Lazy Loading', () => {
    it('should support code splitting patterns', async () => {
      // This test verifies the app structure supports lazy loading
      const { container } = renderApp(<App />);
      
      // App should render initial content
      await waitFor(() => {
        expect(container.children.length).toBeGreaterThan(0);
      });
    });
  });
});
